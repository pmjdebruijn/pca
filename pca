#!/bin/sh




DEFAULT_ROOT_YEARS=30
DEFAULT_INTER_YEARS=15
DEFAULT_LEAF_YEARS=2

ALGO=RSA

COUNTRY=US
ORGANIZATION="ACME Corporation"




BASENAME=$(basename --suffix '.sh' $0)

[ -f /etc/${BASENAME}.conf ] && . /etc/${BASENAME}.conf && echo "Configuration /etc/${BASENAME}.conf loaded..."
[ -f ~/.${BASENAME}.conf ] && . ~/.${BASENAME}.conf && echo "Configuration ~/.${BASENAME}.conf loaded..."
[ -f ./${BASENAME}.conf ] && . ./${BASENAME}.conf && echo "Configuration ./${BASENAME}.conf loaded..."




case ${ALGO} in
  RSA)
    ROOT_KEY_PARAMS='--rsa --bits 4096 --hash sha384'
    LEAF_KEY_PARAMS='--rsa --bits 2048 --hash sha256'
    ;;
  ECDSA)
    ROOT_KEY_PARAMS='--ecdsa --curve secp384r1 --hash sha384'    # estimated sec equiv to RSA7680
    LEAF_KEY_PARAMS='--ecdsa --curve secp256r1 --hash sha256'    # estimated sec equiv to RSA3072
    ;;
  *)
    echo "${BASENAME}: invalid ALGO: ${ALGO}" 1>&2 && exit 1
    ;;
esac




[ ! -x "$(which certtool)" ] && echo "${BASENAME} needs certtool (gnutls-bin) anywhere in ${PATH}" 1>&2 && exit 1

[ ! -x "$(which gpg)" ] && echo "${BASENAME} needs gpg (gnupg) anywhere in ${PATH}" 1>&2 && exit 1

[ ! -x "$(which git)" ] && echo "${BASENAME} needs git (git) anywhere in ${PATH}" 1>&2 && exit 1




MODE=leaf

while getopts ':n:d:y:o:l:s:c:irf' OPT "$@"; do
  case ${OPT} in
    n) NAME=${OPTARG} ;;
    d) DNS_NAMES=${OPTARG} ;;
    y) YEAR=${OPTARG} ;;
    o) ORGANIZATION=${OPTARG} ;;
    l) LOCALITY=${OPTARG} ;;
    s) STATE=${OPTARG} ;;
    c) COUNTRY=${OPTARG} ;;
    i) MODE=inter && LEAF_KEY_PARAMS=${ROOT_KEY_PARAMS} ;;
    r) MODE=revoke ;;
    f) FORCE=IAMSURE ;;
    *)
      echo "Usage: ${BASENAME} [OPTION] CERTIFICATE_AUTHORITY [LEAF_CERTIFICATE]"    2>&1
      echo "           -n  primary domain name (common name)"                        2>&1
      echo "           -d  additional domain names (dns san)"                        2>&1
      echo "           -y  year (valid up to and including)"                         2>&1
      echo "           -o  organisation name"                                        2>&1
      echo "           -l  locality (city)"                                          2>&1
      echo "           -s  state (province)"                                         2>&1
      echo "           -c  country code (iso)"                                       2>&1
      echo "           -i  generate an intermediate certificate authority"           2>&1
      echo "           -r  revoke certificate"                                       2>&1
      echo "           -f  force certificate signing request"                        2>&1
      exit 1
      ;;
  esac
done

shift $(( ${OPTIND} - 1 ))

CA_ROOT=$(echo $1 | tr 'A-Z' 'a-z' | tr -cd '0-9a-z-/' | cut -d '/' -f 1)
CERT_ROOT=$(echo $1 | tr 'A-Z' 'a-z' | tr -cd '0-9a-z-/')
CERT_LEAF=$(echo $2 | sed 's#^*#wildcard#g'| tr 'A-Z' 'a-z' | tr '.' '-' | tr -cd '0-9a-z-')

CERT_ROOT_NAME=$1
CERT_LEAF_NAME=$2




gitcommit ()
{
  git -C ${CA_ROOT} init --quiet
  git -C ${CA_ROOT} add --all
  git -C ${CA_ROOT} commit --quiet --all --message "$1: $2" --message "$(git -C ${CA_ROOT} status --porcelain)" \
      --author "$(getent passwd ${SUDO_USER:-${USER}} | cut -d ':' -f 5 | cut -d ',' -f 1) <${SUDO_USER:-${USER}}@$(hostname -f)>"

  chmod 700 ${CA_ROOT}/.git
}




genpass ()
{
  echo $(head -c 48 /dev/urandom | base64 -w 0 | tr -d '/+=oO01iIl5S8B' | tail -c 24) | tee $1
  [ -f $1 ] && chmod 600 $1
}




md5sums ()
{
  (cd $1; md5sum *[^md5])
}




crlbundle ()
{
  cat $(find $1 -name "*.crl" -not -name "*.bundle.crl" -type f | sort)
}




crtbundle ()
{
  local D=$1

  while [ "${D}" != "" ]; do
    if [ -f ${D}/$(basename ${D}).crt ]; then
      cat ${D}/$(basename ${D}).crt
    else
      echo "${BASENAME}: missing certificate ${D}/$(basename ${D}).crt" 1>&2 && exit 1
    fi
    D=$(echo ${D} | sed "s#/\?$(basename ${D})\$##g")
  done
}




template ()
{
  case $1 in
    root)
      echo "expiration_date = '${YEAR:-$(( $(date +%Y) + ${DEFAULT_ROOT_YEARS} ))}-12-31 23:59:59 UTC'"
      echo "organization = '${ORGANIZATION}'"
      echo "unit = '${NAME:-${CERT_ROOT_NAME}} Trust Network'"
      [ "${LOCALITY}" != "" ] && echo "locality = '${LOCALITY}'"
      [ "${STATE}" != "" ] && echo "state = '${STATE}'"
      echo "country = ${COUNTRY}"
      echo "cn = '${NAME:-${CERT_ROOT_NAME} Private $ALGO Root Certification Authority $(date +%Y)}'"
      echo "#path_len = 1"
      echo "ca"
      echo "cert_signing_key"
      echo "crl_signing_key"
      echo "crl_next_update 365"
    ;;
    inter)
      echo "expiration_date = '${YEAR:-$(( $(date +%Y) + ${DEFAULT_INTER_YEARS} ))}-12-31 23:59:59 UTC'"
      echo "organization = '${ORGANIZATION}'"
      echo "unit = '${NAME:-${CERT_ROOT_NAME}} Trust Network'"
      [ "${LOCALITY}" != "" ] && echo "locality = '${LOCALITY}'"
      [ "${STATE}" != "" ] && echo "state = '${STATE}'"
      echo "country = ${COUNTRY}"
      echo "cn = '${NAME:-${CERT_ROOT_NAME} ${CERT_LEAF_NAME} $ALGO Intermediate Certification Authority $(date +%Y)}'"
      echo "#path_len = 0"
      echo "ca"
      echo "cert_signing_key"
      echo "crl_signing_key"
      ;;
    leaf)
      echo "expiration_date = '${YEAR:-$(( $(date +%Y) + ${DEFAULT_LEAF_YEARS} ))}-12-31 23:59:59 UTC'"
      echo "organization = '${ORGANIZATION}'"
      [ "${LOCALITY}" != "" ] && echo "locality = '${LOCALITY}'"
      [ "${STATE}" != "" ] && echo "state = '${STATE}'"
      echo "country = ${COUNTRY}"
      echo "cn = '${NAME:-${CERT_LEAF_NAME}}'"
      echo "dns_name = '${NAME:-${CERT_LEAF_NAME}}'"    # Subject Alternative Name
      for DNS_NAME in ${DNS_NAMES}; do
        echo "dns_name = '${DNS_NAME}'"                 # Subject Alternative Name
      done
      echo "signing_key"
      echo "encryption_key"
      echo "tls_www_server"
      echo "tls_www_client"
      ;;
    sign)
      echo "expiration_date = '${YEAR:-$(( $(date +%Y) + ${DEFAULT_LEAF_YEARS} ))}-12-31 23:59:59 UTC'"
      echo "honor_crq_ext = 2.5.29.17"                  # Subject Alternative Name
      for DNS_NAME in ${DNS_NAMES}; do
        echo "dns_name = '${DNS_NAME}'"                 # Subject Alternative Name
      done
      echo "signing_key"
      echo "encryption_key"
      echo "tls_www_server"
      echo "tls_www_client"
      ;;
    *)
      echo "${BASENAME}: internal $0 error, $1 template unknown!" 1>&2 && exit 1
      ;;
  esac
}




[ -f /proc/sys/kernel/random/entropy_avail ] && while [ $(cat /proc/sys/kernel/random/entropy_avail) -lt 1000 ]; do sleep 1; done




if [ $# -eq 1 ] && [ "${MODE}" != "revoke" ] &&                                                   \
   [ ! -d ${CERT_ROOT} ]; then

  mkdir -p ${CERT_ROOT}
  certtool --generate-privkey                 ${ROOT_KEY_PARAMS}                                  \
           --outfile                          ${CERT_ROOT}/${CERT_ROOT}.key

  template root                             > ${CERT_ROOT}/${CERT_ROOT}.cfg
  certtool --generate-self-signed                                                                 \
           --template                         ${CERT_ROOT}/${CERT_ROOT}.cfg                       \
           --load-privkey                     ${CERT_ROOT}/${CERT_ROOT}.key                       \
           --outfile                          ${CERT_ROOT}/${CERT_ROOT}.crt

  md5sums ${CERT_ROOT}                      > ${CERT_ROOT}/${CERT_ROOT}.md5

  certtool --generate-crl                                                                         \
           --template                         ${CERT_ROOT}/${CERT_ROOT}.cfg                       \
           --load-ca-privkey                  ${CERT_ROOT}/${CERT_ROOT}.key                       \
           --load-ca-certificate              ${CERT_ROOT}/${CERT_ROOT}.crt                       \
           --outfile                          ${CERT_ROOT}/${CERT_ROOT}.crl

  crlbundle ${CA_ROOT}                      > ${CA_ROOT}/${CA_ROOT}.bundle.crl

  gitcommit "new root"                        ${CERT_ROOT}

fi

if [ $# -eq 2 ] && [ "${MODE}" = "revoke" ] &&                                                    \
   [   -f ${CERT_ROOT}/$(basename ${CERT_ROOT}).key  ] &&                                         \
   [   -f ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.crt ]; then

  certtool --generate-crl                                                                         \
           --load-crl                         ${CERT_ROOT}/$(basename ${CERT_ROOT}).crl           \
           --template                         ${CERT_ROOT}/$(basename ${CERT_ROOT}).cfg           \
           --load-ca-privkey                  ${CERT_ROOT}/$(basename ${CERT_ROOT}).key           \
           --load-ca-certificate              ${CERT_ROOT}/$(basename ${CERT_ROOT}).crt           \
           --load-certificate                 ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.crt          \
           --outfile                          ${CERT_ROOT}/$(basename ${CERT_ROOT}).crlx

  if [ $? -eq 0 ]; then
    mv ${CERT_ROOT}/$(basename ${CERT_ROOT}).crlx ${CERT_ROOT}/$(basename ${CERT_ROOT}).crl
    mv ${CERT_ROOT}/${CERT_LEAF} ${CERT_ROOT}/${CERT_LEAF}_REVOKED_$(date +%Y%m%d%H%M%S)
  fi

  crlbundle ${CA_ROOT}                      > ${CA_ROOT}/${CA_ROOT}.bundle.crl

  gitcommit "revoke"                          ${CERT_ROOT}/${CERT_LEAF}

fi

if [ $# -eq 2 ] && [ "${MODE}" != "revoke" ] &&                                                   \
   [   -f ${CERT_ROOT}/$(basename ${CERT_ROOT}).key ] &&                                          \
   [   -f ${CERT_ROOT}/$(basename ${CERT_ROOT}).crl ] &&                                          \
   [ ! -d ${CERT_ROOT}/${CERT_LEAF}                 ]; then

  mkdir -p ${CERT_ROOT}/${CERT_LEAF}
  certtool --generate-privkey                 ${LEAF_KEY_PARAMS}                                  \
           --outfile                          ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.key

  template ${MODE}                          > ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.cfg
  certtool --generate-certificate                                                                 \
           --template                         ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.cfg          \
           --load-privkey                     ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.key          \
           --outfile                          ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.crt          \
           --load-ca-privkey                  ${CERT_ROOT}/$(basename ${CERT_ROOT}).key           \
           --load-ca-certificate              ${CERT_ROOT}/$(basename ${CERT_ROOT}).crt

  [ "${MODE}" = "leaf" ] &&                                                                       \
  crtbundle ${CERT_ROOT}/${CERT_LEAF}       > ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.bundle.crt

  [ "${MODE}" = "leaf" ] &&                                                                       \
  certtool --to-p12 --outder                                                                      \
           --p12-name                         ${CERT_LEAF}                                        \
           --load-privkey                     ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.key          \
           --load-certificate                 ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.bundle.crt   \
           --outfile                          ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.bundle.pfx   \
           --password               $(genpass ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.bundle.txt)

  [ "${MODE}" = "leaf" ] &&                                                                       \
  tar      --create --owner=0 --group=0                                                           \
           --file - --directory               ${CERT_ROOT}/${CERT_LEAF} ${CERT_LEAF}.key          \
                                                                        ${CERT_LEAF}.crt          \
                                                                        ${CERT_LEAF}.bundle.crt   \
              | gpg --quiet --symmetric --armor                                                   \
                    --compress-algo Uncompressed --digest-algo SHA256 --cipher-algo AES128        \
                    --batch --passphrase-file ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.bundle.txt   \
                                            > ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.bundle.asc

  md5sums ${CERT_ROOT}/${CERT_LEAF}         > ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.md5

  [ "${MODE}" = "inter" ] &&                                                                      \
  certtool --generate-crl                                                                         \
           --template                         ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.cfg          \
           --load-ca-privkey                  ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.key          \
           --load-ca-certificate              ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.crt          \
           --outfile                          ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.crl

  [ "${MODE}" = "inter" ] &&                                                                      \
  crlbundle ${CA_ROOT}                      > ${CA_ROOT}/${CA_ROOT}.bundle.crl

  gitcommit "new $MODE"                       ${CERT_ROOT}/${CERT_LEAF}

fi

if [ $# -eq 2 ] && [ "${MODE}" != "revoke" ] &&                                                   \
   [   -f ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.csr ] &&                                         \
   [ ! -f ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.crt ]; then

  certtool --crq-info --infile                ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.csr

  [ "${FORCE}" != "IAMSURE" ] && read -p "Do you want to sign the above certificate signing request? (Type IAMSURE to continue): " FORCE
  [ "${FORCE}" != "IAMSURE" ] && echo "Aborting" 1>&2 && exit 1

  template sign                             > ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.cfg

  certtool --generate-certificate             ${LEAF_KEY_PARAMS}                                  \
           --template                         ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.cfg          \
           --load-request                     ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.csr          \
           --outfile                          ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.crt          \
           --load-ca-privkey                  ${CERT_ROOT}/$(basename ${CERT_ROOT}).key           \
           --load-ca-certificate              ${CERT_ROOT}/$(basename ${CERT_ROOT}).crt

  [ "${MODE}" = "leaf" ] &&                                                                       \
  crtbundle ${CERT_ROOT}/${CERT_LEAF}       > ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.bundle.crt

  [ "${MODE}" = "leaf" ] &&                                                                       \
  certtool --to-p12 --outder                                                                      \
           --p12-name                         ${CERT_LEAF}                                        \
           --load-certificate                 ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.bundle.crt   \
           --outfile                          ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.bundle.pfx   \
           --password                password # Windows compliance

  md5sums ${CERT_ROOT}/${CERT_LEAF}         > ${CERT_ROOT}/${CERT_LEAF}/${CERT_LEAF}.md5

  gitcommit "sign"                            ${CERT_ROOT}/${CERT_LEAF}

fi
